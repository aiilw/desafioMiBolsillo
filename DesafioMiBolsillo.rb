#!/usr/bin/env ruby

# Represents the Graph
class Graph
	
	# Initializes the list of Nodes that
	# this Graph contains to an empty list
	def initialize()
		@nodes = nil
	end
	
	# Adds a Node to the list of Nodes of
	# this Graph
	# @params: 
	#	node: an instance of the class Node.
	def addNode(node)
		if @nodes.nil?
			@nodes = [node]
		else
			@nodes << node
		end
	end
	
	# @return: true iff the name of the Node is 
	#	hold by any Node in the list of this Graph.
	# @params:
	#	name: the String representing the name of the Node.
	def containsNode?(name)
		if @nodes.nil?
			return nil
		end
		@nodes.each do |node|
			if name == node.getName()
				return true
			end
		end
		return false
	end
	
	# @return: the Node specified by name
	#	or nil if this Graph does not contain such Node.
	def getNode(name)
		if @nodes.nil?
			return nil
		end
		@nodes.each do |node|
			if name == node.getName()
				return node
			end
		end
		return nil
	end
end

# Represents a Node
class Node

	# Initializes the name of the current Node
	# to the parameter name and the list of Paths
	# that start from this Node to an empty list.
	# @params:
	#	name: a single character String identifying
	#		this Node.
	def initialize(name)
		@name = name
		@paths = nil
	end
	
	# Adds a Path to the list of Paths that start
	# on this Node.
	# @params:
	#	path: an instance of the class Path.
	def addPath(path)
		if @paths.nil?
			@paths = [path]
		else
			@paths << path
		end
	end
	
	# The getter for the class attributes
	def getName()
		return @name
	end
	
	def getPaths()
		return @paths
	end
	
	# Searches paths for a destination Node given by name
	# @return: the Path that relates this Node to the requested
	#	Node or nil if such Path does not exist.
	def pathTo(name)
		if @paths.nil?
			return nil
		end
		@paths.each do |path|
			if path.getDestination().getName() == name
				return path
			end
		end
		return nil
	end
	
	# @return the list of destination Nodes from current Node.
	def getDestinations()
		dests = []
		if @paths.nil?
			return nil
		end
		@paths.each do |path|
			dests << path.getDestination()
		end
		return dests
	end
	
	# For debugging purposes only just to be sure
	# that the paths are being allocated to the 
	# same array properly.
	def putPaths()
		if @paths.nil?
			puts "Empty Path"
		elsif @paths.respond_to?("join")
			puts "Path: #{@paths.join(", ")}"
		else
			puts "Path: #{@paths}"
		end
	end
end

# Represents a Directed Edge between to Nodes
class Path
	
	# Initializes the Path setting the Origin
	# Node, the Destination Node and the Weight
	# between those Nodes.
	# @params
	#	onode: Origin Node
	#	dnode: Destination Node
	#	weight: a positive integer
	def initialize(onode, dnode, weight)
		@onode = onode
		@dnode = dnode
		@weight = weight
	end
	
	# Getters for the class attributes
	def getDestination()
		return @dnode
	end
	
	def getOrigin()
		return @onode
	end
	
	def getWeight()
		return @weight
	end
end

# Reads an input graph from the console and loads the data into
# a Graph structure
# @return: the Graph generated by input data.
def readGraph
	puts "Please, input the Graph as a comma-separated " +
		"sequence of Edges and press Enter"
	graphString = gets
	pathsString = graphString.split(",")
	graph0 = Graph.new
	pathsString.each do |pathString|
		pathString = pathString.strip()
		onode = nil
		dnode = nil
		if graph0.containsNode?(pathString[0])
			onode = graph0.getNode(pathString[0])
		else
			onode = Node.new(pathString[0])
			graph0.addNode(onode)
		end
		if graph0.containsNode?(pathString[1])
			dnode = graph0.getNode(pathString[1])
		else
			dnode = Node.new(pathString[1])
			graph0.addNode(dnode)
		end
		weight = pathString[2, pathString.size].to_i()
		p0 = Path.new(onode, dnode, weight)
		onode.addPath(p0)
	end
	return graph0
end

# OBSOLETE
# Outputs the distance of the route A-B-C or
# "NO SUCH ROUTE" in case there is no such a route.
def output1(graph0)
	nodeA = graph0.getNode("A")
	pathAB = nodeA.pathTo("B")
	nodeB = graph0.getNode("B")
	pathBC = nodeB.pathTo("C")
	if pathAB.nil? or pathBC.nil?
		puts "NO SUCH ROUTE"
		return
	end
	distance = pathAB.getWeight() + pathBC.getWeight()
	puts "Output # 1: #{distance.to_s}"
end

# @return: the distance to travel in a specified route
#	in this Graph or nil if there is no such a route.
# @params: graph0 is the current Graph and route is an
#	array of Nodes' names.
def outputRoute(graph0, route)
	if route.nil?
		return
	end
	node0 = graph0.getNode(route[0])
	distance = 0
	for count in 1..route.size() - 1
		path01 = node0.pathTo(route[count])
		if path01.nil?
			return nil
		end
		distance += path01.getWeight()
		node0 = graph0.getNode(route[count])
	end
	return distance
end

# @return: the number of possible trips between two Nodes
#	given a number of stops.
# @params: graph0 is the current Graph, oname is the name of
#	the starting Node, dname is the name of the destination Node
#	hops is the number of stops.
def countTrips(graph0, oname, dname, hops)
	count = 0
	onode = graph0.getNode(oname)
	curdest = [onode]
	for index in 1..hops
		newdest = []
		curdest.each do |cnode|
			newdest = newdest + cnode.getDestinations()
		end
		curdest = newdest
	end
	curdest.each do |cnode|
		if cnode.getName() == dname
			count += 1
		end
	end
	return count
end

# @return: number of trips starting on C and ending on C with
#	a maximum of 3 stops.
def output6(graph0)
	count = 0
	for hop in 1..3
		count = count + countTrips(graph0, "C", "C", hop)
	end
	return count
end

# @return: the shortest distance between two Nodes if such exists
#	or nil if there is no route.
# @params: graph0, the current Graph; oname, the name of the
#	starting Node; dname, the name of the destination Node.
def shortestRoute(graph0, oname, dname)
	# Initializes the data for the first node
	onode = graph0.getNode(oname)
	opaths = onode.getPaths()
	shortest = {}
	visited = [oname]
	tovisit = []
	opaths.each do |opath|
		cname = opath.getDestination().getName()
		shortest[cname] = opath.getWeight()
		tovisit << cname
	end
	# Records the shortest path to any node while 
	# there are still nodes without visiting.
	while tovisit.size() > 0
		nuvisit = []
		tovisit.each do |toname|
			tonode = graph0.getNode(toname)
			topaths = tonode.getPaths()
			visited << toname
			topaths.each do |topath|
				cname = topath.getDestination().getName()
				nuweight = topath.getWeight() + shortest[toname]
				if shortest.has_key?(cname)
					if nuweight < shortest[cname]
						shortest[cname] = nuweight
					end
				else
					shortest[cname] = nuweight
				end
				if !(visited.include?(cname) || tovisit.include?(cname))
					nuvisit << cname
				end
			end
		end
		tovisit = nuvisit
	end
	if shortest.has_key?(dname)
		return shortest[dname]
	else
		return nil
	end
end

# @return: the number of routes starting from certain Node and ending
#	on another Node whose total distance of travel is less than maxlen.
# @params: graph0, the current Graph; oname, the name of the starting Node;
#	dname, the name of the destination Node; maxlen, the maximum total distance
#	allowed between the two Nodes.
def countRoutesShorterThan(graph0, oname, dname, maxlen)
	onode = graph0.getNode(oname)
	distances = {}
	distances[oname] = 0
	routes = [oname]
	uncharted = [oname]
	# Extends the routes step by step by breadth-first and stops to go
	# deeper when finds that the distance is greater than maxlen.
	while uncharted.size() > 0
		nucharted = []
		uncharted.each do |uname|
			unode = graph0.getNode(uname[-1])
			upaths = unode.getPaths()
			upaths.each do |upath|
				weight = upath.getWeight() + distances[uname]
				if weight < maxlen
					cname = upath.getDestination().getName()
					rname = uname + cname
					distances[rname] = weight
					routes << rname
					nucharted << rname
				end
			end
		end
		uncharted = nucharted
	end
	count = 0
	routes.each do |route|
		if route[-1] == dname
			count += 1
		end
	end
	if dname == oname
		count -= 1
	end
	return count
end

# Execute if being the main routine and not called as a library
if __FILE__ == $0
	graph0 = readGraph()
#	Alternative way of calculating the distance for a specific
#	route.
#	output1(graph0)
	routes = [["A", "B", "C"], ["A", "D"], ["A", "D", "C"], 
		["A", "E", "B", "C", "D"], ["A", "E", "D"]]
	count = 0
	routes.each do |route|	
		count = count + 1
		distance = outputRoute(graph0, route)
		if distance.nil?
			puts "Output # #{count.to_s}: NO SUCH ROUTE"
		else
			puts "Output # #{count.to_s}: #{distance.to_s}"
		end
	end
	count = output6(graph0)
	puts "Output # 6: #{count.to_s}"
	count = countTrips(graph0, "A", "C", 4)
	puts "Output # 7: #{count.to_s}"
	distance = shortestRoute(graph0, "A", "C")
	if distance.nil?
		puts "Output # 8: There is no route between A and C."
	else
		puts "Output # 8: #{distance.to_s}"
	end
	distance = shortestRoute(graph0, "B", "B")
	if distance.nil?
		puts "Output # 9: There is no route between B and B."
	else
		puts "Output # 9: #{distance.to_s}"
	end
	count = countRoutesShorterThan(graph0, "C", "C", 30)
	puts "Output # 10: #{count.to_s}"
	gets
end